:NewDefs

class Some[out T](x: T) {
  fun flatMap(f: T -> (Some['A] | None)): (Some['A] | None) = f(x)
}
module None {
  fun flatMap(f) = None
}
//│ class Some[T](x: T) {
//│   fun flatMap: (f: T -> (None | Some[anything])) -> (None | Some[nothing])
//│ }
//│ module None {
//│   fun flatMap: anything -> None
//│ }

type Option[out A] = Some[A] | None
//│ type Option[A] = None | Some[A]


class Var(x: Num)
class Lam[E](x: Num, e: E)
module Uni
//│ class Var(x: Num)
//│ class Lam[E](x: Num, e: E)
//│ module Uni

class EVal[V](v: V)
class EApp[E](e1: E, e2: E)
//│ class EVal[V](v: V)
//│ class EApp[E](e1: E, e2: E)


mixin STLCBase {
  
  fun eval(e) =
    if e is
      EVal(v) then Some(v)
      EApp(e1, e2) then this.eval(e1).flatMap(f => this.apply(e2, f))
  
  fun subst(x, e0, e) =
    if e is
      // EVal(v) then this.substVal(x, e0, v)
      EVal(v) then
        if v is
          Var(y) then e0
          Lam(y, e1) then EVal(Lam(y, this.subst(x, e0, e1)))
        else EVal(v) // ?? e does not work here
      EApp(e1, e2) then EApp(this.subst(x, e0, e1), this.subst(x, e0, e2))
  
  // fun substVal(x, e0, v) =
  //   if v is
  //     Var(y) and y == x then e0
  //     Lam(y, e1) then EVal(Lam(y, this.subst(x, e0, e1)))
  //   else EVal(v)
  
  fun apply(e2, f) =
    if f is
      Lam(x, e) then this.eval(this.subst(x, e2, e))
    else None
}
//│ mixin STLCBase() {
//│   this: {
//│     apply: ('a, 'b) -> 'c,
//│     eval: 'a -> {flatMap: ('b -> 'c) -> 'd} & 'e -> 'f,
//│     subst: ('g, 'h, 'i) -> 'E & ('g, 'h, 'j) -> 'E0 & (Num, 'k, 'l) -> 'e
//│   }
//│   fun apply: ('k, Lam['l] | Object & ~#Lam) -> (None | 'f)
//│   fun eval: (EApp['a] | EVal['T]) -> (Some['T] | 'd)
//│   fun subst: ('g, 'h, EApp['j] | EVal[Lam['i] | Object & 'V & ~#Lam & ~#Var | Var]) -> (EApp['E0] | EVal[in 'V out 'V | Lam['E]] | 'h)
//│ }


:e
module STLC extends STLCBase
//│ ╔══[ERROR] Subtyping constraint of the form `#STLC & {
//│   apply: (?a, ?b) -> ?c,
//│   eval: ?d -> (?e | ?f),
//│   subst: (?g, ?h, ?i) -> (?h | ?j | ?k | ?l)
//│ } <: ?sTLC` exceeded recursion depth limit (250)
//│ ║  l.74: 	module STLC extends STLCBase
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╙── Note: use flag `:ex` to see internal error info.
//│ module STLC {
//│   fun apply: ('a, Lam['b] | Object & ~#Lam) -> (None | Some['V | 'V0 | 'V1 | 'T | 'T0 | 'A])
//│   fun eval: forall 'T1. (EApp['c] | EVal['T1 & 'T0 & 'A & (Lam['E] | Object & ~#Lam)]) -> (None | Some['V | 'V0 | 'V1 | 'T | 'T1 | 'A])
//│   fun subst: forall 'V2. (anything, 'a, EApp['b] | EVal[Lam['b] | Object & 'V2 & ~#Lam & ~#Var | Var]) -> (EVal[in 'V2 & 'V out 'V2 | Lam['E0] | 'V3] | 'a)
//│ }
//│ where
//│   'V2 :> 'V0
//│       <: 'V1 & (Lam['E1] & ~#Lam | Lam['E & 'E1] | Object & 'V0 & ~#Lam & ~#Var | Var)
//│   'a :> EVal[in 'V0 out 'V0 | 'V1] | 'd
//│      <: EApp['E2 & 'E3] | EVal['V4 & 'A & 'T & (Lam['E] | Object & ~#Lam)]
//│   'd :> EApp['E4] | EVal[in 'V3 & (Lam['E1] & ~#Lam | Lam['E & 'E1] | Object & 'V0 & ~#Lam & ~#Var | Var) out 'V]
//│   'E4 :> EVal[in 'V0 out 'V0 | 'V1] | 'a | 'd
//│       <: 'E2 & 'E3
//│   'E3 <: 'c
//│   'c <: 'a & (EApp['E3] | EVal['A & 'T & (Lam['E] | Object & ~#Lam)])
//│   'A :> 'V0 | 'V1 | 'V
//│      <: Lam['E] | Object & ~#Lam
//│   'V :> Lam['E0] | 'V3
//│   'E0 :> EVal[in 'V0 out 'V0 | 'V1] | 'a | 'd
//│       <: 'E & 'E1
//│   'V0 <: Lam['E1] & ~#Lam | Lam['E & 'E1] | Object & ~#Lam & ~#Var | Var
//│   'E <: 'b
//│   'E1 <: 'b
//│   'b <: EApp['E2] | EVal['V4]
//│   'V4 <: Lam['E1] | Object & 'V0 & ~#Lam & ~#Var | Var
//│   'E2 <: 'b

mixin STLCBaseClosed {
  
  type STLCBaseVal = Uni | Var | Lam[STLCBaseExp]
  type STLCBaseExp = EVal[STLCBaseVal] | EApp[STLCBaseExp]
  
  fun eval(e: STLCBaseExp): Option[STLCBaseVal] =
    if e is
      EVal(v) then Some(v)
      EApp(e1, e2) then this.eval(e1).flatMap(f => this.apply(e2, f))
  
  fun subst(x, e0, e) =
    if e is
      // EVal(v) then this.substVal(x, e0, v)
      EVal(v) then
        if v is
          Var(y) then e0
          Lam(y, e1) then EVal(Lam(y, this.subst(x, e0, e1)))
        else EVal(v) // ?? e does not work here
      EApp(e1, e2) then EApp(this.subst(x, e0, e1), this.subst(x, e0, e2))
  
  // fun substVal(x, e0, v) =
  //   if v is
  //     Var(y) and y == x then e0
  //     Lam(y, e1) then EVal(Lam(y, this.subst(x, e0, e1)))
  //   else EVal(v)
  
  fun apply(e2, f) =
    if f is
      Lam(x, e) then this.eval(this.subst(x, e2, e))
    else None
}
//│ mixin STLCBaseClosed() {
//│   this: {
//│     apply: (STLCBaseExp, 'a) -> 'b,
//│     eval: STLCBaseExp -> {flatMap: ('a -> 'b) -> Option[STLCBaseVal]} & 'c -> 'd,
//│     subst: ('e, 'f, 'g) -> 'E & ('e, 'f, 'h) -> 'E0 & (Num, 'i, 'j) -> 'c
//│   }
//│   type STLCBaseExp = EApp[STLCBaseExp] | EVal[STLCBaseVal]
//│   type STLCBaseVal = Lam[STLCBaseExp] | Uni | Var
//│   fun apply: ('i, Lam['j] | Object & ~#Lam) -> (None | 'd)
//│   fun eval: (e: STLCBaseExp) -> Option[STLCBaseVal]
//│   fun subst: ('e, 'f, EApp['h] | EVal[Lam['g] | Object & 'V & ~#Lam & ~#Var | Var]) -> (EApp['E0] | EVal[in 'V out 'V | Lam['E]] | 'f)
//│ }

module STLCClosed extends STLCBaseClosed
//│ module STLCClosed {
//│   type STLCBaseExp = EApp[STLCBaseExp] | EVal[STLCBaseVal]
//│   type STLCBaseVal = Lam[STLCBaseExp] | Uni | Var
//│   fun apply: (STLCBaseExp, Lam['a] | Object & ~#Lam) -> (None | Option[STLCBaseVal])
//│   fun eval: (e: STLCBaseExp) -> Option[STLCBaseVal]
//│   fun subst: forall 'V 'V0. (anything, STLCBaseExp, EApp['a] | EVal[Lam['a] | Object & 'V & ~#Lam & ~#Var | Var]) -> (EApp['E] | EVal['V & 'V0] | STLCBaseExp)
//│ }
//│ where
//│   'V0 :> Lam[STLCBaseExp] | Lam['E0] | Uni | Var | 'V1
//│       <: 'V2
//│   'E :> EVal[in 'V3 & (Lam[STLCBaseExp] | Uni | Var) out Lam[STLCBaseExp] | Uni | Var | 'V3 | 'V4] | STLCBaseExp | 'b
//│      <: STLCBaseExp
//│   'b :> EApp['E] | EVal[in 'V1 & (Lam[STLCBaseExp] | Uni | Var) out 'V2]
//│   'V2 :> Lam[STLCBaseExp] | Lam['E0] | Uni | Var | 'V1
//│       <: Lam[STLCBaseExp] | Uni | Var
//│   'E0 :> EVal[in 'V3 & (Lam[STLCBaseExp] | Uni | Var) out Lam[STLCBaseExp] | Uni | Var | 'V3 | 'V4] | STLCBaseExp | 'b
//│       <: STLCBaseExp
//│   'V :> Lam[STLCBaseExp] | Uni | Var | 'V3
//│      <: 'V4 & (Lam[STLCBaseExp] | Uni | Var)
//│   'a <: EApp['a] | EVal[Lam['a] | Uni & 'V3 | Var]

STLCClosed.eval(EApp(EVal(Lam(0, EVal(Var(0)))), EVal(Uni)))
//│ Option[STLCBaseVal]
//│ res
//│     = Some {}


// FIXME
mixin STLCBaseOpen[ThisVal, ThisExp] {
  
  type STLCBaseVal = Uni | Var | Lam[ThisExp]
  type STLCBaseExp = EVal[ThisVal] | EApp[ThisExp]
  
  fun eval(e: EVal[ThisVal | Uni | Var | Lam[ThisExp]] | EApp[ThisExp]): Option[ThisVal | Uni | Var | Lam[ThisExp]] =
    if e is
      EVal(v) then Some(v)
      EApp(e1, e2) then this.eval(e1).flatMap(f => this.apply(e2, f))
  
  // we need STLCBaseVal <: ThisVal and STLCBaseExp <: ThisExp
  fun subst(x: Num, e0: ThisExp, e: EVal[ThisVal | Uni | Var | Lam[ThisExp]] | EApp[ThisExp]): ThisExp | EVal[ThisVal | Lam[ThisExp] | Uni] | EApp[ThisExp] =
    if e is
      EVal(v) then this.substVal(x, e0, v)
      EApp(e1, e2) then EApp(this.subst(x, e0, e1), this.subst(x, e0, e2))
  
  fun substVal(x, e0, v) =
    if v is
      Var(y) and y == x then e0
      Lam(y, e1) then EVal(Lam(y, this.subst(x, e0, e1)))
    else EVal(v)
  
  // The follwing signature does not work:
  // fun apply(e2: ThisExp, f: (ThisVal & Object) | Uni | Var | Lam[ThisExp]): Option[ThisVal] =
  fun apply(e2: ThisExp, f: Uni | Var | Lam[ThisExp]): Option[ThisVal] =
    if f is
      Lam(x, e1) then this.eval(this.subst(x, e2, e1))
    else None
}
//│ mixin STLCBaseOpen[ThisVal, ThisExp]() {
//│   this: {
//│     apply: (ThisExp, 'a) -> 'b,
//│     eval: ThisExp -> {flatMap: ('a -> 'b) -> Option[Lam[ThisExp] | Uni | Var | ThisVal]} & 'c -> Option[ThisVal],
//│     subst: (Num, ThisExp, ThisExp) -> (ThisExp & 'c) & ('d, 'e, 'f) -> 'E,
//│     substVal: (Num, ThisExp, Lam[ThisExp] | Uni | Var | ThisVal) -> (EApp[ThisExp] | EVal[Lam[ThisExp] | Uni | ThisVal] | ThisExp)
//│   }
//│   type STLCBaseExp = EApp[ThisExp] | EVal[ThisVal]
//│   type STLCBaseVal = Lam[ThisExp] | Uni | Var
//│   fun apply: (e2: ThisExp, f: Lam[ThisExp] | Uni | Var) -> Option[ThisVal]
//│   fun eval: (e: EApp[ThisExp] | EVal[Lam[ThisExp] | Uni | Var | ThisVal]) -> Option[Lam[ThisExp] | Uni | Var | ThisVal]
//│   fun subst: (x: Num, e0: ThisExp, e: EApp[ThisExp] | EVal[Lam[ThisExp] | Uni | Var | ThisVal]) -> (EApp[ThisExp] | EVal[Lam[ThisExp] | Uni | ThisVal] | ThisExp)
//│   fun substVal: (Num & 'd, 'e, Lam['f] | Object & 'V & ~#Lam & ~#Var | Var) -> (EVal[in 'V out 'V | Lam['E] | Var] | 'e)
//│ }


module STLC1 extends STLCBaseOpen
//│ module STLC1 {
//│   type STLCBaseExp = EApp['ThisExp] | EVal['ThisVal]
//│   type STLCBaseVal = Lam['ThisExp] | Uni | Var
//│   fun apply: (e2: 'ThisExp, f: Lam['ThisExp] | Uni | Var) -> Option['ThisVal]
//│   fun eval: (e: EApp['ThisExp] | EVal['ThisVal]) -> Option['ThisVal]
//│   fun subst: (x: Num, e0: 'ThisExp, e: EApp['ThisExp] | EVal['ThisVal]) -> 'ThisExp
//│   fun substVal: forall 'V. (Num, 'a, Lam['b] | Object & 'V & ~#Lam & ~#Var | Var) -> (EVal[out Uni | 'V0 | 'V | Lam['E] | Var] | 'a)
//│ }
//│ where
//│   'E :> 'ThisExp
//│   'ThisExp :> EApp['ThisExp] | EVal['ThisVal]
//│            <: 'a & 'E0 & (EApp['ThisExp] | EVal['ThisVal])
//│   'a := 'ThisExp
//│   'ThisVal :> Lam['ThisExp] | Uni | Var
//│            <: Lam['ThisExp & 'E0] | Var | 'V0 & (Lam['ThisExp] & ~#Lam | Uni)
//│   'E0 <: 'b
//│   'b <: EApp['ThisExp] | EVal['ThisVal]


STLC1.eval(EApp(EVal(Lam(0, EVal(Var(0)))), EVal(Uni)))
//│ Option['ThisVal]
//│   where
//│     'ThisVal :> Lam['ThisExp] | Uni | Var
//│              <: Lam['ThisExp & 'E] | Var | Lam['ThisExp] & ~#Lam | Uni
//│     'ThisExp :> EApp['ThisExp] | EVal['ThisVal & 'V & 'V0]
//│              <: 'E & (EApp['ThisExp] | EVal['ThisVal])
//│     'E <: EApp['ThisExp] | EVal['ThisVal]
//│     'V0 :> Lam[in 'ThisExp out 'ThisExp | EVal['V1]] | 'ThisVal
//│         <: 'ThisVal
//│     'V1 :> Var
//│     'V := 'ThisVal
//│ res
//│     = Some {}

// ***********************  IF EXTENSION  ***********************
module Tru
module Fal
class EIf[E](e: E, e1: E, e2: E)
//│ module Tru
//│ module Fal
//│ class EIf[E](e: E, e1: E, e2: E)

// type STLCBaseVal = Uni | Var | Lam[STLCBaseExp]
// //│ ╔══[ERROR] type identifier not found: STLCBaseExp
// //│ ║  l.308: 	type STLCBaseVal = Uni | Var | Lam[STLCBaseExp]
// //│ ╙──       	                                   ^^^^^^^^^^^
// //│ TEST CASE FAILURE: There was an unexpected type error
// //│ type STLCBaseVal = Lam[error] | Uni | Var
// type STLCBaseExp = EVal[STLCBaseVal] | EApp[STLCBaseExp]
// //│ type STLCBaseExp = EApp[STLCBaseExp] | EVal[STLCBaseVal]

// type STLCExtVal = Tru | Fal | Uni | Var | Lam[STLCExtExp]
// type STLCExtExp = EVal[STLCExtVal] | EApp[STLCExtExp] | EIf[STLCExtExp]
// //│ type STLCExtVal = Fal | Lam[STLCExtExp] | Tru | Uni | Var
// //│ type STLCExtExp = EApp[STLCExtExp] | EIf[STLCExtExp] | EVal[STLCExtVal]


mixin STLCIf {
  fun eval(e) =
    if e is
      EIf(e, e1, e2) then this.eval(e).flatMap(b => this.branch(e1, e2, b))
    else super.eval(e)
  
  fun branch(e1, e2, b) =
    if b is
      Tru then this.eval(e1)
      Fal then this.eval(e2)
    else None
  
  fun subst(x, e0, e) =
    if e is
      EIf(e, e1, e2) then EIf(this.subst(x, e0, e), this.subst(x, e0, e1), this.subst(x, e0, e2))
    else super.subst(x, e0, e)
  
  fun substVal(x, e0, v) =
    if v is
      Tru then EVal(Tru)
      Fal then EVal(Fal)
    else super.substVal(x, e0, v)
}
//│ mixin STLCIf() {
//│   super: {eval: 'a -> 'b, subst: ('c, 'd, 'e) -> 'f, substVal: ('g, 'h, 'i) -> 'j}
//│   this: {
//│     branch: ('k, 'k, 'l) -> 'm,
//│     eval: 'k -> {flatMap: ('l -> 'm) -> 'b} & 'n -> 'o,
//│     subst: ('c, 'd, 'p) -> 'E
//│   }
//│   fun branch: ('n, 'n, Object) -> (None | 'o)
//│   fun eval: (EIf['k] | Object & 'a & ~#EIf) -> 'b
//│   fun subst: ('c, 'd, EIf['p] | Object & 'e & ~#EIf) -> (EIf['E] | 'f)
//│   fun substVal: ('g, 'h, Fal | Object & 'i & ~#Fal & ~#Tru | Tru) -> (EVal[in 'V out Fal | 'V | Tru] | 'j)
//│ }

